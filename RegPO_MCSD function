RegPO_MCSD <- function(X,y,c,alpha=1,beta=1,m.knots=6){
  #c ## observation time, n by 1
  #X ## covariate matrix, n by p
  #y ## test result, 1 for positive, 0 for negative
  #alpha ## sensitivity
  #beta ## specificity 
  n = length(y) ## sample size
  p = ncol(X) ## dimension of the covariate vector
  
  tau =1 ### for PO model
  
  m= m.knots ###specify m equally spaced knots, robust to m
  
  ##################### loading library
  library(dlm)
  library(stats)
  library(MASS)
  library(coda)
  
  
  #################### loading functions
  ## update covariate params: theta
  fun_theta <- function(theta,EZ,bis,EZl,Exi,X){
    gal <- matrix(0,nrow =1,ncol = L)
    for (l in 1:L){
      gal[l] <- sum(EZl[,l])/sum(Exi*bis[l,]*exp(X%*%theta))
    }
    Lambdac1 <- t(gal%*%bis)
    p1 <- EZ*log(Lambdac1)
    p2 <- (X%*%theta)*EZ
    p3 <- Lambdac1*Exi*exp(X%*%theta)
    res <- -sum(p1+p2-p3)
    return(res)
  }
  
  MIspline<-function(x,order,knots){
    # get M spline and I spline matrix with order
    # x is a row vector
    # k is the order of I spline
    # knots are a sequence of increasing points
    # the number of free parameters in M spline is the length of knots plus 1.
    
    
    ### Mspline bases ###
    k1=order  ###degree
    m=length(knots)
    n1=m-2+k1 # number of parameters = # of knots + degree -2
    t1=c(rep(1,k1)*knots[1], knots[2:(m-1)], rep(1,k1)*knots[m]) # newknots 
    
    tem1=array(rep(0,(n1+k1-1)*length(x)),dim=c(n1+k1-1, length(x)))
    for (l in k1:n1){
      tem1[l,]=(x>=t1[l] & x<t1[l+1])/(t1[l+1]-t1[l])
    }
    
    if (order==1){
      mbases=tem1
    }else{
      mbases=tem1
      for (ii in 1:(order-1)){
        tem=array(rep(0,(n1+k1-1-ii)*length(x)),dim=c(n1+k1-1-ii, length(x)))
        for (i in (k1-ii):n1){
          tem[i,]=(ii+1)*((x-t1[i])*mbases[i,]+(t1[i+ii+1]-x)*mbases[i+1,])/(t1[i+ii+1]-t1[i])/ii
        }
        mbases=tem
      }
    }
    
    ### get Ispline bases ###
    k=order+1
    n=m-2+k # number of parameters
    t=c(rep(1,k)*knots[1], knots[2:(m-1)], rep(1,k)*knots[m]) # newknots
    
    yy1=array(rep(0,(n+k-1)*length(x)),dim=c(n+k-1, length(x)))
    for (l in k:n){
      yy1[l,]=(x>=t[l] & x<t[l+1])/(t[l+1]-t[l])
    }
    
    yytem1=yy1
    for (ii in 1:order){
      yytem2=array(rep(0,(n+k-1-ii)*length(x)),dim=c(n+k-1-ii, length(x)))
      for (i in (k-ii):n){
        yytem2[i,]=(ii+1)*((x-t[i])*yytem1[i,]+(t[i+ii+1]-x)*yytem1[i+1,])/(t[i+ii+1]-t[i])/ii
      }
      yytem1=yytem2
    }
    
    
    index=rep(0,length(x))
    for (i in 1:length(x)){
      index[i]=sum(t<=x[i])
    }
    
    ibases=array(rep(0,(n-1)*length(x)),dim=c(n-1,length(x)))
    
    if (order==1){
      for (i in 2:n){
        ibases[i-1,]=(i<index-order+1)+(i==index)*(t[i+order+1]-t[i])*yytem2[i,]/(order+1)
      }
    }else{
      for (j in 1:length(x)){
        for (i in 2:n){
          if (i<(index[j]-order+1)){
            ibases[i-1,j]=1
          }else if ((i<=index[j]) && (i>=(index[j]-order+1))){
            ibases[i-1,j]=(t[(i+order+1):(index[j]+order+1)]-t[i:index[j]])%*%yytem2[i:index[j],j]/(order+1)
          }else{
            ibases[i-1,j]=0
          }
        }
      }
    }
    return(list(mbases,ibases))
  }
  
  ############# splines
  #### setup knots and degree
  minobs = min(c)
  maxobs = max(c)+.2
  knots = seq(0,maxobs,length.out=m)
  order = 3
  L = length(knots)-2+order # the number of Ispline bases 
  bis = MIspline(t(c),order,knots)[[2]] # report each b_l(c_i) [1:L,1:n]
  
  grids=seq(0.1,2.5,by=0.03)
  bgs=MIspline(grids,order,knots)[[2]]
  
  ###################### initial theta, gamma_l (method robust to initial values)
  theta = runif(p,-1,1)
  gam <- matrix(runif(L,0,1),nrow=1,ncol=L)
  
  ####baseline function 
  Lambdac=t(gam%*%bis)
  
  err_theta = theta
  rerr_lobs = 1
  err_alpha = alpha
  err_beta = beta
  iter = 1
  #Beta is given, estimate alpha
  if (identical(alpha,FALSE) && !identical(beta,FALSE)){
    alpha = runif(1,0.5,1) ##initial alpha
    while (max(err_theta,err_alpha,rerr_lobs)> 1e-4){
      Lambdac = t(gam%*%bis)
      K = Lambdac*exp(X%*%theta)
      SCX = (tau/(tau+K))^tau
      l1 = (1-SCX)*(alpha^y)*(1-alpha)^(1-y)
      l2 = SCX*beta^(1-y)*(1-beta)^y
      EDel = l1/(l1+l2)
      EZ = K/(1-SCX)*EDel
      EZl = matrix(0,nrow = n,ncol = L)
      for (i in 1:n){
        for (l in 1:L){
          EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
        }
      }
      Exi = (EZ+tau)/(K+tau)
      lobs.1=alpha- (alpha+beta-1)*SCX
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      
      ####M step
      theta.f <- theta
      theta <-optim(theta,fun_theta,method = "Nelder-Mead",EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
      err_theta <- abs(theta-theta.f)
      
      gam.f <- gam
      for (l in 1:L){
        Xp <- exp(X%*%theta)
        gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
      }
      gam <- gam
      
      alpha.f <- alpha
      alpha=sum(EDel*y)/sum(EDel)
      err_alpha=abs(alpha-alpha.f)
      
      lobs.f <- lobs
      K = t(gam%*%bis)*exp(X%*%theta)
      SCX = (tau/(tau+K))^tau
      lobs.1=alpha- (alpha+beta-1)*SCX
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
      iter=iter+1
    }
    
    fun_setheta.se<- function(theta,gam,bis,X,y,alpha,beta,tau){
      Lambdac= t(gam%*%bis)
      ka=alpha+beta-1
      ka.tau=ka*tau^(tau+1)
      colnames(X) <- NULL
      eX=exp(X%*%theta)
      Laexp=Lambdac*eX
      Labexp.tau=Laexp+tau
      p=length(theta)
      L=length(gam)
      n=length(y)
      
      denu=alpha-ka*(tau/Labexp.tau)^tau
      nu1=ka.tau*Laexp/Labexp.tau^(tau+1)
      nu2=ka.tau*eX/Labexp.tau^(tau+1)
      nu3=1-(tau/Labexp.tau)^tau
      
      a1=nu1/denu
      a2=nu1/(1-denu)
      a3=nu2/denu
      a4=nu2/(1-denu)
      
      #alpha
      a5=nu3/denu
      a6=-nu3/(1-denu)
      
      #empty matrix
      matC=matrix(0,L+p+1,L+p+1)
      
      for(i in 1:n){
        dl.dtheta=y[i]*a1[i]*X[i,]-(1-y[i])*a2[i]*X[i,]
        dl.dgam=y[i]*a3[i]*bis[,i]-(1-y[i])*a4[i]*bis[,i]
        dl.dalpha=y[i]*a5[i]-(1-y[i])*a6[i]
        matA=as.matrix(c(dl.dtheta,dl.dalpha,dl.dgam),ncol=L+p+1,nrow=1)
        matB=matA%*%t(matA)
        matC=matC+matB
      }
      matD=solve(matC+diag(1e-6,L+p+1,L+p+1))
      var.theta.se=diag(matD)[1:(p+1)]
      se.theta.se = sqrt(var.theta.se)
      param_names <-c(paste0("se.theta",1:p), "se.alpha")
      names(se.theta.se) <- param_names
      return(se.theta.se)
    }
    setheta.se <- fun_setheta.se(theta=theta,gam=gam,bis=bis,X=X,y=y,alpha=alpha,beta=beta,tau=tau)
    return(list(theta=theta,alpha=alpha,se=setheta.se))
    
  }
  
  #alpha is given, etimate beta
  else if (!identical(alpha,FALSE) && identical(beta,FALSE)){
    beta = runif(1,0.5,1) ##initial beta
    while (max(err_theta,err_beta,rerr_lobs)> 1e-4){
      Lambdac = t(gam%*%bis)
      K = Lambdac*exp(X%*%theta)
      SCX = (tau/(tau+K))^tau
      l1 = (1-SCX)*(alpha^y)*(1-alpha)^(1-y)
      l2 = SCX*beta^(1-y)*(1-beta)^y
      EDel = l1/(l1+l2)
      EZ = K/(1-SCX)*EDel
      EZl = matrix(0,nrow = n,ncol = L)
      for (i in 1:n){
        for (l in 1:L){
          EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
        }
      }
      Exi = (EZ+tau)/(K+tau)
      lobs.1=alpha- (alpha+beta-1)*SCX
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      
      ####M step
      theta.f <- theta
      theta <-optim(theta,fun_theta,method = "Nelder-Mead",EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
      err_theta <- abs(theta-theta.f)
      
      gam.f <- gam
      for (l in 1:L){
        Xp <- exp(X%*%theta)
        gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
      }
      gam <- gam
      
      beta.f <- beta
      beta=sum((1-EDel)*(1-y))/sum(1-EDel)
      err_beta=abs(beta-beta.f)
      
      lobs.f <- lobs
      K = t(gam%*%bis)*exp(X%*%theta)
      SCX = (tau/(tau+K))^tau
      lobs.1=alpha- (alpha+beta-1)*SCX
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
      iter=iter+1
    }
    
    fun_setheta.sp<- function(theta,gam,bis,X,y,alpha,beta,tau){
      Lambdac= t(gam%*%bis)
      ka=alpha+beta-1
      ka.tau=ka*tau^(tau+1)
      colnames(X) <- NULL
      eX=exp(X%*%theta)
      Laexp=Lambdac*eX
      Labexp.tau=Laexp+tau
      p=length(theta)
      L=length(gam)
      n=length(y)
      
      denu=alpha-ka*(tau/Labexp.tau)^tau
      nu1=ka.tau*Laexp/Labexp.tau^(tau+1)
      nu2=ka.tau*eX/Labexp.tau^(tau+1)
      nu3=1-(tau/Labexp.tau)^tau
      
      a1=nu1/denu
      a2=nu1/(1-denu)
      a3=nu2/denu
      a4=nu2/(1-denu)
      
      #beta
      a7=(nu3-1)/denu
      a8=(nu3-1)/(1-denu)
      
      #empty matrix
      matC=matrix(0,L+p+1,L+p+1)
      
      for(i in 1:n){
        dl.dtheta=y[i]*a1[i]*X[i,]-(1-y[i])*a2[i]*X[i,]
        dl.dgam=y[i]*a3[i]*bis[,i]-(1-y[i])*a4[i]*bis[,i]
        dl.dbeta=y[i]*a7[i]-(1-y[i])*a8[i]
        matA=as.matrix(c(dl.dtheta,dl.dbeta,dl.dgam),ncol=L+p+1,nrow=1)
        matB=matA%*%t(matA)
        matC=matC+matB
      }
      matD=solve(matC+diag(1e-6,L+p+1,L+p+1))
      var.theta.sp=diag(matD)[1:(p+1)]
      se.theta.sp = sqrt(var.theta.sp)
      param_names <-c(paste0("se.theta",1:p), "se.beta")
      names(se.theta.sp) <- param_names
      return(se.theta.sp)
    }
    setheta.sp <- fun_setheta.sp(theta=theta,gam=gam,bis=bis,X=X,y=y,alpha=alpha,beta=beta,tau=tau)
    return(list(theta=theta,beta=beta,se=setheta.sp))
  }
  
  #alpha and beta both missing
  else if (identical(alpha,FALSE) && identical(beta,FALSE)){
    alpha = runif(1,0.5,1) ##initial alpha
    beta = runif(1,0.5,1) ##initial beta
    while (max(err_theta,err_alpha,err_beta,rerr_lobs)> 1e-4){
      Lambdac = t(gam%*%bis)
      K = Lambdac*exp(X%*%theta)
      SCX = (tau/(tau+K))^tau
      l1 = (1-SCX)*(alpha^y)*(1-alpha)^(1-y)
      l2 = SCX*beta^(1-y)*(1-beta)^y
      EDel = l1/(l1+l2)
      EZ = K/(1-SCX)*EDel
      EZl = matrix(0,nrow = n,ncol = L)
      for (i in 1:n){
        for (l in 1:L){
          EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
        }
      }
      Exi = (EZ+tau)/(K+tau)
      lobs.1=alpha- (alpha+beta-1)*SCX
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      
      ####M step
      theta.f <- theta
      theta <-optim(theta,fun_theta,method = "Nelder-Mead",EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
      err_theta <- abs(theta-theta.f)
      
      gam.f <- gam
      for (l in 1:L){
        Xp <- exp(X%*%theta)
        gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
      }
      gam <- gam
      
      alpha.f <- alpha
      beta.f <- beta
      alpha=sum(EDel*y)/sum(EDel)
      beta=sum((1-EDel)*(1-y))/sum(1-EDel)
      err_alpha=abs(alpha-alpha.f)
      err_beta=abs(beta-beta.f)
      
      lobs.f <- lobs
      K = t(gam%*%bis)*exp(X%*%theta)
      SCX = (tau/(tau+K))^tau
      lobs.1=alpha- (alpha+beta-1)*SCX
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
      iter=iter+1
    }
    
    fun_setheta.sesp<- function(theta,gam,bis,X,y,alpha,beta,tau){
      Lambdac= t(gam%*%bis)
      ka=alpha+beta-1
      ka.tau=ka*tau^(tau+1)
      colnames(X) <- NULL
      eX=exp(X%*%theta)
      Laexp=Lambdac*eX
      Labexp.tau=Laexp+tau
      p=length(theta)
      L=length(gam)
      n=length(y)
      
      denu=alpha-ka*(tau/Labexp.tau)^tau
      nu1=ka.tau*Laexp/Labexp.tau^(tau+1)
      nu2=ka.tau*eX/Labexp.tau^(tau+1)
      nu3=1-(tau/Labexp.tau)^tau
      
      a1=nu1/denu
      a2=nu1/(1-denu)
      a3=nu2/denu
      a4=nu2/(1-denu)
      
      #alpha
      a5=nu3/denu
      a6=-nu3/(1-denu)
      #beta
      a7=(nu3-1)/denu
      a8=(nu3-1)/(1-denu)
      
      #empty matrix
      matC=matrix(0,L+p+2,L+p+2)
      
      for(i in 1:n){
        dl.dtheta=y[i]*a1[i]*X[i,]-(1-y[i])*a2[i]*X[i,]
        dl.dgam=y[i]*a3[i]*bis[,i]-(1-y[i])*a4[i]*bis[,i]
        dl.dalpha=y[i]*a5[i]-(1-y[i])*a6[i]
        dl.dbeta=y[i]*a7[i]-(1-y[i])*a8[i]
        matA=as.matrix(c(dl.dtheta,dl.dalpha,dl.dbeta,dl.dgam),ncol=L+p+2,nrow=1)
        matB=matA%*%t(matA)
        matC=matC+matB
      }
      matD=solve(matC+diag(1e-6,L+p+2,L+p+2))
      var.theta.sesp=diag(matD)[1:(p+2)]
      se.theta.sesp = sqrt(var.theta.sesp)
      param_names <-c(paste0("se.theta",1:p), "se.alpha","se.beta")
      names(se.theta.sesp) <- param_names
      return(se.theta.sesp)
    }
    setheta.sesp <- fun_setheta.sesp(theta=theta,gam=gam,bis=bis,X=X,y=y,alpha=alpha,beta=beta,tau=tau)
    return(list(theta=theta,alpha=alpha,beta=beta,se=setheta.sesp))
  }
  
  #alpha and beta are both given
  else{
    while (max(err_theta,rerr_lobs)> 1e-4){
      Lambdac = t(gam%*%bis)
      l1 = Lambdac*exp(X%*%theta)*(alpha^y)*(1-alpha)^(1-y)
      l2 = beta^(1-y)*(1-beta)^y
      
      #### E step
      EDel = l1/(l1+l2)
      EZ = (Lambdac*exp(X%*%theta)+1)*EDel
      Exi = (EZ+1)/(1+Lambdac*exp(X%*%theta))
      EZl = matrix(0,nrow = n,ncol = L)
      for (i in 1:n){
        for (l in 1:L){
          EZl[i,l] = EZ[i]*gam[l]*bis[l,i]/Lambdac[i]
        }
      }
      lobs.1 = alpha- (alpha+beta-1)/(1+Lambdac*exp(X%*%theta))
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      
      #### M step
      theta.f <- theta
      theta <- optim(theta,fun_theta, method="Nelder-Mead", EZ=EZ,bis=bis,EZl=EZl,Exi=Exi,X=X)$par
      err_theta <- abs(theta-theta.f)
      gam.f <- gam
      for (l in 1:L){
        Xp <- exp(X%*%theta)
        gam[l]<- sum(EZl[,l])/sum(Exi*bis[l,]*Xp)
      }
      gam <- gam
      lobs.f <- lobs
      lobs.1 = alpha- (alpha+beta-1)/(1+t(gam%*%bis)*exp(X%*%theta))
      lobs.0 = 1-lobs.1
      lobs = sum(log(lobs.1[y==1]))+sum(log(lobs.0[y==0]))
      rerr_lobs <- abs((lobs -lobs.f)/lobs.f)
      iter = iter+1
    }
    
    fun_setheta <- function(theta,gam,bis,X,y,alpha,beta){
      Lambdac = t(gam%*%bis)
      ka = alpha+beta-1
      colnames(X) <- NULL
      eX = exp(X%*%theta)
      Laexp = Lambdac*eX
      Labexp.1 = Laexp+1
      p = length(theta)
      L = length(gam)
      n = length(y)
      
      #empty matrix
      
      matC = matrix(0,L+p,L+p)
      for(i in 1:n){
        dl.dtheta = y[i]*ka*Laexp[i]/Labexp.1[i]^2/(alpha-ka/Labexp.1[i])*X[i,]-(1-y[i])*ka*Laexp[i]/Labexp.1[i]^2/(1-alpha+ka/Labexp.1[i])*X[i,]
        dl.dgam = y[i]*ka*eX[i]/(alpha*Labexp.1[i]^2-ka*Labexp.1[i])*bis[,i]-(1-y[i])*ka*eX[i]/((1-alpha)*Labexp.1[i]^2+ka*Labexp.1[i])*bis[,i]
        matA = as.matrix(c(dl.dtheta,dl.dgam),ncol=L+p,nrow=1)
        matB = matA%*%t(matA)
        matC = matC + matB
      }
      matD = solve(matC+diag(1e-6,L+p,L+p))
      var.theta = diag(matD)[1:p]
      se.theta = sqrt(var.theta)
      param_names <-c(paste0("se.theta",1:p))
      names(se.theta) <- param_names
      return(se.theta)
    }
    se.theta <- fun_setheta(theta,gam,bis,X,y,alpha,beta)
    return(list(theta=theta,se=se.theta))
  }
  
}



